!function(){angular.module("jsDocNG-Data",[]).constant("$title","USRZ Esquire API (v. 0.0.2)").constant("$readme","<h1>Esquire</h1><p>Esquire is a light weight, <strong>asynchronous</strong> injection framework for JavaScript.</p>\n<div class=\"nojsdoc\">\n  The full API documentation is avaiblable\n  <a target=\"_blank\" href=\"http://usrz.github.io/javascript-esquire/\">here</a>.\n</div>\n\n<h2>Modules</h2><p>Module definitions are shared, on a per <em>global scope</em> basis; in other words,\nthe same module is defined only once per <code>window</code> if running in a browser,\nor <code>global</code> if running under <code>Node.JS</code>.</p>\n<p>Modules are defined by a <code>name</code>, a list of <em>dependencies</em>, and a constructor\nfunction:</p>\n<pre class=\"prettyprint source lang-javascript\"><code>Esquire.define(&quot;myModuleName&quot;, ['myFirstDependency', 'anotherDependency'], function(first, another) {\n  // the parameters to the constructor are our dependencies, and in this context\n  // &quot;this&quot; means the module itself, so &quot;this.name&quot; is &quot;myModuleName&quot;\n});</code></pre><p>Constructors can return <em>immediately</em> (with a result), or can return a\n<em>then-able</em> <code>Promise</code> which will eventually resolve to the required instance.</p>\n<h2>Module Injection</h2><p>Direct injection of a module is supported through the <code>inject(...)</code> method,\nwhich will return a <code>Promise</code> to its return value:</p>\n<pre class=\"prettyprint source lang-javascript\"><code>new Esquire().inject(['dependencyName'], function(dependency) {\n  // ... use the dependency here, and either return or throw an exception\n\n}).then(function(result) {\n  // &quot;result&quot; here will be the value returned by the injected method above\n\n}, function(failure) {\n  // &quot;failure&quot; here will be the error thrown by the injected method above\n\n});</code></pre><h2>Module Requirement</h2><p>Modules can also be directly required by the caller, and will be returned\nwrapped into a <code>Promise</code>:</p>\n<pre class=\"prettyprint source lang-javascript\"><code>new Esquire().require('requestedModule')\n  .then(function(result) {\n    // &quot;result&quot; here will be the instance of the module 'requestedModule'\n  });</code></pre><p>Multiple modules can also be requested simultaneously (both specifying module\nnames as arguments or an array of <code>string</code>s):</p>\n<pre class=\"prettyprint source lang-javascript\"><code>new Esquire().require('firstModule', 'secondModule')\n  .then(function(result) {\n    // result[0] -> instance of 'firstModule'\n    // result[1] -> instance of 'secondModule'\n  });</code></pre><h2>Static vs. per-instance injection</h2><p>In the examples above, a call to <code>new Esquire()</code> will create a new <em>injector</em>\nand with it, new modules instances are created. Each module <em>instance</em> is only\navailable to its injector, and never shared across.</p>\n<p>On the other hand the global <code>esquire(...)</code> method will allow to access a per\n<em>global scope</em> shared injector.</p>\n<p>When calling <code>esquire(...)</code> with a callback function as its last parameter,\nthe method will behave like <code>inject(...)</code>, thus dependencies will be resolved\nand passed to callback method, and its return value (if any) will be returned.</p>\n<pre class=\"prettyprint source lang-javascript\"><code>esquire(['dependencyName'], function(dependency) {\n  // ... use the dependency here, and either return or throw an exception\n}).then(function(result) {\n  // &quot;result&quot; here will be the value returned by the injected method above\n});</code></pre><p>If no callback function was given, the <code>esquire(...)</code> method will behave like\n<code>require(...)</code> and simply return the required dependencies.</p>\n<pre class=\"prettyprint source lang-javascript\"><code>esquire('requestedModule')\n  .then(function(result) {\n    // &quot;result&quot; here will be the instance of the module 'requestedModule'\n  });</code></pre><h2>Timeouts</h2><p>As module creation is asynchronous, it might be useful to specify a timeout\nwhen creation should fail.</p>\n<p>By default the timeout is 2000 ms (2 sec), but a different timeout can be\nspecified at construction time. The minimum timeout is 100 ms.</p>\n<pre class=\"prettyprint source lang-javascript\"><code>new Esquire(60000).require('foo')\n  .then(function(foo) {\n    // we'll wait up to a minute for &quot;foo&quot; to be created\n  });</code></pre><h2>Loading</h2><p>While optional, loading of external scripts is also supported, with the same\n<code>Promise</code> mechanism (especially useful in browser environments).</p>\n<p>And as <code>Promise</code>s can be easily chained, constructs like the following can\nbe quite useful:</p>\n<pre class=\"prettyprint source lang-javascript\"><code>Esquire.load(&quot;myOtherScript.js&quot;)\n  .then(function() {\n    return esquire(&quot;moduleFromMyOtherScript&quot;);\n  })\n.then(function(myModule) {\n  // here &quot;myModule&quot; will be the shared global instance of the module\n  // &quot;moduleFromMyOtherScript&quot; defined in the &quot;myOtherScript.js&quot; file\n});</code></pre>").constant("$doclets",[{kind:"typedef",name:"Deferred",type:{names:["module:$deferred.Deferred"]},longname:"Deferred",scope:"global",$href:"#Deferred",$id:"T000002R000002"},{kind:"typedef",name:"Promise",type:{names:["module:$promise.Promise"]},longname:"Promise",scope:"global",$href:"#Promise",$id:"T000002R000003"},{description:'<p>Create a new <a href="#!/#Deferred"><code>Deferred</code></a> instance.</p>',kind:"class",name:"Deferred",examples:["-\nEsquire.define(\"myModule\", ['$deferred'], function(Deferred) {\n var deferred = new Deferred();\n // ....\n return deferred.promise;\n});"],memberof:"module:$deferred",longname:"module:$deferred.Deferred",scope:"static",$href:"module:$deferred.Deferred",$id:"T000002R000004"},{description:"<p>Resolve this instance's derived <code>promise</code> with the specified <em>success</em> value.</p>",params:[{type:{names:["*","Promise"]},description:"<p>If the value is a <em>then-able</em> (i.e. has a <code>then(...)</code> method) this instance's derived <code>promise</code> will <strong>follow</strong> that <em>then-able</em>, adopting its eventual state.</p>",name:"success"}],kind:"function",name:"resolve",memberof:"module:$deferred.Deferred",longname:"module:$deferred.Deferred#resolve",scope:"instance",$href:"module:$deferred.Deferred#resolve",$id:"T000002R000013"},{description:"<p>Rejects this instance's derived <code>promise</code> with the specified <em>failure</em> reason.</p>",params:[{type:{names:["*"]},description:"<p>The reason for rejection.</p>",name:"failure"}],kind:"function",name:"reject",memberof:"module:$deferred.Deferred",longname:"module:$deferred.Deferred#reject",scope:"instance",$href:"module:$deferred.Deferred#reject",$id:"T000002R000023"},{description:'<p>The derived <a href="#!/#Promise"><code>Promise</code></a> associated with this <a href="#!/#Deferred"><code>Deferred</code></a> instance.</p>',kind:"member",name:"promise",type:{names:["Promise"]},memberof:"module:$deferred.Deferred",longname:"module:$deferred.Deferred#promise",scope:"instance",$href:"module:$deferred.Deferred#promise",$id:"T000002R000033"},{description:'<p>Create a new <a href="#!/#Promise"><code>Promise</code></a> instance.</p>',kind:"class",name:"Promise",classdesc:'<p>The <a href="#!/#Promise"><code>Promise</code></a> class provides a minimal implementation of JavaScript <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a>s</p>',params:[{type:{names:["function"]},description:"<p>A function object with two arguments (<code>resolve</code> and <code>reject</code>). The first argument fulfills the promise, the second argument rejects it. We can call these functions, once our operation is completed, with the appropriate values for <em>fulfillment</em> or <em>rejection</em>.</p>",name:"executor"}],examples:["-\nEsquire.define(\"myModule\", ['$promise'], function(Promise) {\n return new Promise(function(resolve, reject) {\n   // ... resolve or reject this promise...\n  });\n});"],memberof:"module:$promise",longname:"module:$promise.Promise",scope:"static",$href:"module:$promise.Promise",$id:"T000002R000049"},{description:'<p>Appends fulfillment and rejection handlers to this <a href="#!/#Promise"><code>Promise</code></a>, and returns a <strong>new</strong> promise resolving to the return value of the called handler.</p>',params:[{type:{names:["function"]},optional:!0,description:'<p>The handler to call when this <a href="#!/#Promise"><code>Promise</code></a> has been successfully resolved.</p>',name:"onSuccess"},{type:{names:["function"]},optional:!0,description:'<p>The handler to call when this <a href="#!/#Promise"><code>Promise</code></a> has been rejected.</p>',name:"onFailure"}],returns:[{type:{names:["Promise"]},description:'<p>A new <a href="#!/#Promise"><code>Promise</code></a> resolving to the return value of the called handler</p>'}],kind:"function",name:"then",memberof:"module:$promise.Promise",longname:"module:$promise.Promise#then",scope:"instance",$href:"module:$promise.Promise#then",$id:"T000002R000052"},{description:'<p>Appends a rejection handler to this <a href="#!/#Promise"><code>Promise</code></a>, and returns a <strong>new</strong> promise resolving to the return value of the called handler.</p> <p>This is equivalent to calling <code>then(null, onFailure)</code>.</p>',params:[{type:{names:["function"]},optional:!0,description:'<p>The handler to call when this <a href="#!/#Promise"><code>Promise</code></a> has been rejected.</p>',name:"onFailure"}],returns:[{type:{names:["Promise"]},description:'<p>A new <a href="#!/#Promise"><code>Promise</code></a> resolving to the return value of the called handler</p>'}],kind:"function",name:"catch",memberof:"module:$promise.Promise",longname:"module:$promise.Promise#catch",scope:"instance",$href:"module:$promise.Promise#catch",$id:"T000002R000056"},{description:'<p>Returns a <a href="#!/#Promise"><code>Promise</code></a> that resolves when all of the values or <em>then-able</em> in the <em>iterable</em> argument have resolved.</p> <p>If any of the promises in the <em>iterable</em> is resolved with a rejection, the returned <a href="#!/#Promise"><code>Promise</code></a> will be rejected with the same rejection value.</p>',params:[{type:{names:["iterable"]},description:"<p>A collection of values or _then-able_s.</p>",name:"iterable"}],returns:[{type:{names:["Promise"]},description:'<p>A <a href="#!/#Promise"><code>Promise</code></a>.</p>'}],kind:"function",name:"all",memberof:"module:$promise.Promise",longname:"module:$promise.Promise.all",scope:"static",$href:"module:$promise.Promise#all",$id:"T000002R000062"},{description:'<p>Returns a <a href="#!/#Promise"><code>Promise</code></a> that resolves or rejects as soon as one of of the values or <em>then-able</em> in the specified <em>iterable</em> resolves or rejects, with the value or reason from that promise.</p>',params:[{type:{names:["iterable"]},description:"<p>Foo.</p>",name:"iterable"}],returns:[{type:{names:["Promise"]},description:'<p>A <a href="#!/#Promise"><code>Promise</code></a>.</p>'}],kind:"function",name:"race",memberof:"module:$promise.Promise",longname:"module:$promise.Promise.race",scope:"static",$href:"module:$promise.Promise#race",$id:"T000002R000073"},{description:'<p>Returns a <a href="#!/#Promise"><code>Promise</code></a> object that is resolved with the given value.</p> <p>If the value is a <em>then-able</em> (i.e. has a <code>then(...)</code> method), the returned promise will <strong>follow</strong> that <em>then-able</em>, adopting its eventual state; otherwise the returned promise will be fulfilled.</p>',params:[{type:{names:["*","Promise"]},description:"<p>The resolution result or <em>then-able</em> to follow.</p>",name:"success"}],returns:[{type:{names:["Promise"]},description:'<p>A resolved <a href="#!/#Promise"><code>Promise</code></a>.</p>'}],kind:"function",name:"resolve",memberof:"module:$promise.Promise",longname:"module:$promise.Promise.resolve",scope:"static",$href:"module:$promise.Promise#resolve",$id:"T000002R000079"},{description:'<p>Returns a <a href="#!/#Promise"><code>Promise</code></a> object that is rejected with the given reason.</p>',params:[{type:{names:["*"]},description:"<p>The rejection reason.</p>",name:"failure"}],returns:[{type:{names:["Promise"]},description:'<p>A rejected <a href="#!/#Promise"><code>Promise</code></a>.</p>'}],kind:"function",name:"reject",memberof:"module:$promise.Promise",longname:"module:$promise.Promise.reject",scope:"static",$href:"module:$promise.Promise#reject",$id:"T000002R000083"},{kind:"class",name:"Module",classdesc:'<p>The definition of an <a href="#!/Esquire"><code>Esquire</code></a> module</p>',access:"protected",longname:"Module",scope:"global",$href:"Module",$id:"T000002R000110"},{description:'<p>The name of this <a href="#!/Module"><code>Module</code></a></p>',kind:"member",name:"name",type:{names:["string"]},readonly:!0,memberof:"Module",longname:"Module#name",scope:"instance",$href:"Module#name",$id:"T000002R000115"},{description:'<p>The name of all dependencies required by this <a href="#!/Module"><code>Module</code></a> (in order).</p>',kind:"member",name:"dependencies",type:{names:["Array.<string>"]},readonly:!0,memberof:"Module",longname:"Module#dependencies",scope:"instance",$href:"Module#dependencies",$id:"T000002R000119"},{description:'<p>The constructor function creating instances of this <a href="#!/Module"><code>Module</code></a>.</p>',kind:"member",name:"constructor",type:{names:["function"]},readonly:!0,memberof:"Module",longname:"Module#constructor",scope:"instance",$href:"Module#constructor",$id:"T000002R000123"},{description:'<p>Define a <a href="#!/Module"><code>Module</code></a> as available to Esquire</p>',kind:"function",name:"define",examples:["-\nEsquire.define('foo', ['modA', 'depB'], function(a, b) {\n // 'a' will be an instance of 'modA'\n // 'b' will be an instance of 'depB'\n function Foo(aInstance, bInstance) {\n   // ...\n };\n return new Foo(a, b);\n});","Definition with a <a href=\"#!/Module\"><code>Module</code></a>-like object also works.\nEsquire.define({\n name: 'foo',\n dependencies: ['modA', 'depB'],\n constructor: function(a, b) {\n   // ...\n }\n});"],params:[{type:{names:["string"]},description:"<p>The name of the module to define.</p>",name:"name"},{type:{names:["Array.<string>"]},optional:!0,description:"<p>An array of required module names whose instances will be passed to the <code>constructor(...)</code> method.</p>",name:"dependencies"},{type:{names:["function"]},description:'<p>A function that will be invoked once per each <a href="#!/Esquire"><code>Esquire</code></a> instance. Its return value will be injected in any other module requiring this module as a dependency.</p>',name:"constructor"}],returns:[{type:{names:["Module"]},description:'<p>The new <a href="#!/Module"><code>Module</code></a> created by this call.</p>'}],memberof:"Esquire",longname:"Esquire.define",scope:"static",$href:"Esquire#define",$id:"T000002R000165"},{description:'<p>Return an array of <a href="#!/Module"><code>Module</code></a> dependencies for a <a href="#!/Module"><code>Module</code></a>.</p>',kind:"function",name:"resolve",params:[{type:{names:["string","Module"]},description:'<p>The <a href="#!/Module"><code>Module</code></a> (or its name) for which dependendencies should be resolved.</p>',name:"module"},{type:{names:["boolean"]},optional:!0,description:'<p>If <code>true</code> all direct and indirect <em>(transitive)</em> dependencies will be resolved. If <code>false</code> or <em>undefined</em>, only the <a href="#!/Module"><code>Module</code></a>\'s explicit dependencies will be resolved.</p>',name:"transitive"}],returns:[{type:{names:["Array.<Module>"]},description:'<p>An array of all required <a href="#!/Module"><code>Module</code></a>s.</p>'}],memberof:"Esquire",longname:"Esquire.resolve",scope:"static",$href:"Esquire#resolve",$id:"T000002R000176"},{description:'<p>Create a new <a href="#!/Esquire"><code>Esquire</code></a> injector instance, optionally specifying a timeout (in milliseconds) after which module resolution fails.</p>',kind:"class",name:"Esquire",classdesc:'<p><a href="#!/Esquire#modules"><code>Modules</code></a> are <em>static</em> and shared amongst all <a href="#!/Esquire"><code>Esquire</code></a> instances (see <a href="#!/Esquire#define"><code>define(...)</code></a>), but their instances not, and are only created <em>once</em> for each <a href="#!/Esquire"><code>Esquire</code></a> instance.</p> <p>A <em>globally shared</em> <a href="#!/Esquire"><code>Esquire</code></a> instance can be used by invoking the <a href="#!/#esquire"><code>esquire(...)</code></a> method, rather than creating a new instance and using the <a href="#!/Esquire#require"><code>require(...)</code></a> or <a href="#!/Esquire#inject"><code>inject(...)</code></a> calls.</p>',params:[{type:{names:["number"]},optional:!0,description:"<p>The amount of millisecods to wait for injection, minimum 100 ms, defaults to 2000 ms.</p>",name:"timeout"}],longname:"Esquire",scope:"global",$href:"Esquire",$id:"T000002R000186"},{description:"<p>Require instances for the specified module(s).</p>",scope:"instance",kind:"function",memberof:"Esquire",examples:["-\nvar esq = new Esquire();\n\nesq.require(['fooModule', 'barModule'])\n .then(function(fromArray) {\n   // fromArray[0] will be an instance of 'fooModule'\n   // fromArray[1] will be an instance of 'barModule'\n });","Injection with a single `string` argument\nesq.require('bazModule')\n .then(function(fromString) {\n   // 'fromString' will be an instance of 'bazModule'\n });","Injection with a number of different arguments\nesq.require('abcModule', 'xyzModule')\n .then(function(fromArgs) {\n   // fromArgs[0] will be an instance of 'abcModule'\n   // fromArgs[1] will be an instance of 'xyzModule'\n });"],params:[{type:{names:["Array.<string>","string"]},description:"<p>An array of required module names (or a single module name) whose instance are to be returned.</p>",name:"dependencies"}],returns:[{type:{names:["Array.<Promise>","Promise"]},description:'<p>An array of <a href="#!/#Promise"><code>Promise</code></a>s eventually resolving to the required module instances, or a single <a href="#!/#Promise"><code>Promise</code></a> (if this method was called with a single <code>string</code> parameter).</p>'}],name:"require",longname:"Esquire#require",$href:"Esquire#require",$id:"T000002R000209"},{description:"<p>Request injection for the specified modules.</p>",scope:"instance",kind:"function",name:"inject",memberof:"Esquire",examples:["-\nvar esq = new Esquire();\n\nesq.inject(['modA', 'depB'], function(a, b) {\n // 'a' will be an instance of 'modA'\n // 'b' will be an instance of 'depB'\n return \"something\";\n\n}).then(function(result) {\n // The function will be (eventually) injected with its required\n // modules, and its return value will resolve the promis returned\n // by the \"inject(...) method!\n});","Injection also works without arrays (only arguments)\nesq.inject('modA', 'depB', function(a, b) {\n // 'a' will be an instance of 'modA'\n // 'b' will be an instance of 'depB'\n});","Angular-JS style injection (one big array) is supported, too\nesq.inject(['modA', 'depB', function(a, b) {\n // 'a' will be an instance of 'modA'\n // 'b' will be an instance of 'depB'\n}]);"],params:[{type:{names:["Array.<string>","string"]},optional:!0,description:"<p>An array of required module names whose instances will be passed to the <code>callback(...)</code> method.</p>",name:"dependencies"},{type:{names:["function"]},description:"<p>A function that will be called once all module dependencies have been instantiated, with each instance as a parameter.</p>",name:"callback"}],returns:[{description:'<p><a href="#!/#Promise"><code>Promise</code></a> Whatever value was returned by the <code>callback</code> function.</p>'}],longname:"Esquire#inject",$href:"Esquire#inject",$id:"T000002R000212"},{description:'<p>An unmodifiable dictionary of all <a href="#!/Module"><code>Module</code></a>s known by <a href="#!/Esquire"><code>Esquire</code></a>.</p>',scope:"static",readonly:!0,kind:"member",name:"modules",type:{names:["Object.<string, Module>"]},memberof:"Esquire",examples:['-\n{\n "modA": {\n   "name": "modA",\n   "dependencies": [ ... ],\n   "constructor": function(...) { ... }\n },\n "depB": {\n   "name": "depB",\n   "dependencies": [ ... ],\n   "constructor": function(...) { ... }\n },\n}'],longname:"Esquire.modules",$href:"Esquire#modules",$id:"T000002R000248"},{description:'<p>Return the <a href="#!/Module"><code>Module</code></a> associated with the given <code>name</code> as defined in <a href="#!/Esquire"><code>Esquire</code></a> or <code>null</code>.</p>',scope:"static",kind:"function",name:"module",params:[{type:{names:["string"]},description:'<p>The name of the <a href="#!/Module"><code>Module</code></a> to return.</p>',name:"name"}],memberof:"Esquire",returns:[{type:{names:["Module"]},description:'<p>The <a href="#!/Module"><code>Module</code></a> or <code>null</code></p>'}],longname:"Esquire.module",$href:"Esquire#module",$id:"T000002R000256"},{description:'<p>Request <strong>static</strong> injection for the specified modules.</p> <p>If a <code>callback</code> function was specified, then this method will behave like <a href="#!/Esquire#inject"><code>inject(...)</code></a>, thus dependencies will be resolved and passed to <code>callback</code> method, and its return value (if any) will be returned from this method.</p> <p>If no <code>callback</code> function was given, this method will behave like <code>require(...)</code> and simply return the required dependencies.</p> <p>Note that this method will use a globally shared <a href="#!/Esquire"><code>Esquire</code></a> instance to create and resolve dependencies.</p>',scope:"global",params:[{type:{names:["array"]},description:"<p>An array of required module names whose instances will be passed to the <code>callback(...)</code> method.</p>",name:"dependencies"},{type:{names:["function"]},optional:!0,description:"<p>A function that will be called once all module dependencies have been instantiated, with each instance as a parameter.</p>",name:"callback"}],returns:[{type:{names:["object"]},description:'<p>Whatever value was returned by the <code>callback</code> function (if one was specified) as in <a href="#!/Esquire#inject"><code>Esquire#inject</code></a>.</p>'},{type:{names:["Array.<object>","object"]},description:'<p>An array of module instances (or a single module instance) as in <a href="#!/Esquire#require"><code>Esquire#require</code></a> if this method was called wihtout any <code>callback</code> function.</p>'}],name:"esquire",longname:"esquire",kind:"function",$href:"#esquire",$id:"T000002R000264"},{description:'<p>Load an external script and return a <em>then-able</em> <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Promise"><code>Promise</code></a>.</p>',scope:"static",kind:"function",name:"load",memberof:"Esquire",examples:["-\nEsquire.load('scriptA.js', 'scriptB.js').then(\n function(modules) {\n   // All good: 'modules' will be the same as \"Esquire.modules\"\n },\n function(failure) {\n   // Something bad happend: 'failure' will contain the reason.\n }\n);"],params:[{type:{names:["string","Array.<string>"]},description:"<p>The script(s) to load.</p>",name:"scripts"},{type:{names:["string"]},optional:!0,description:"<p>Any other script names, as arguments, to support calls like <code>load('scriptA.js', 'scriptB.js')</code></p>",name:"..."}],returns:[{type:{names:["Promise"]},description:'<p>A <em>then-able</em> <code>Promise</code> resolving <a href="#!/Esquire#modules"><code>Esquire.modules</code></a>.</p>'}],longname:"Esquire.load",$href:"Esquire#load",$id:"T000002R000280"},{description:'<p>A module exposing a <a href="#!/#Deferred"><code>Deferred</code></a> constructor.</p> <p>The <a href="#!/#Deferred"><code>Deferred</code></a> class behaves much like <em>AngularJS</em>\'s own <a href="https://docs.angularjs.org/api/ng/service/$q#defer"><code>$q.defer()</code></a> method. For more information, look up the <a href="https://docs.angularjs.org/api/ng/service/$q#the-deferred-api">Deferred API</a>.</p>',kind:"module",name:"$deferred",type:{names:["Deferred"]},examples:['Create a new <a href="#!/#Deferred"><code>Deferred</code></a> instance.\nEsquire.define("myModule", [\'$deferred\'], function(Deferred) {\n var deferred = new Deferred();\n // ....\n return deferred.promise;\n});'],longname:"module:$deferred",$href:"module:$deferred",$id:"T000002R000307"},{description:'<p>A module exposing the current <a href="#!/Esquire"><code>Esquire</code></a> instance.</p> <p>The <a href="#!/Module"><code>Module</code></a> constructor function can use this instance to (for example) resolve optional dependencies.</p>',kind:"module",name:"$esquire",type:{names:["Esquire"]},examples:["-\nEsquire.define(\"myModule\", ['$esquire'], function($esquire) {\n $esquire.require('optionalModule')\n   .then(function(optional) {\n     // ... here is the optional module instance\n   }, function(failure) {\n     // module not found? troubles creating?\n   });\n});"],longname:"module:$esquire",$href:"module:$esquire",$id:"T000002R000308"},{description:"<p>A set of dynamic modules exposing the <em>members</em> of <code>$global</code>.</p> <p>This is mostly useful to resolve <code>window</code> members in a browser, when those can be <em>prefixed</em> by the various proprietary schemes.</p> <p>Both the <code>$global/any</code> (standard) and <code>$global.any</code> (alternative) naming schemes are supported, with module names and dependencies being canonicalized to their standard format.</p>",kind:"module",name:"$global/*",type:{names:["*"]},examples:['-\nEsquire.define("crypto", [\'$global/crypto.subtle\'], function(subtle) {\n // "subtle" here can be one of\n // - "$global.crypto.subtle"\n // - "$global.msCrypto.subtle"\n // - "$global.crypto.webkitSubtle"\n // - ... or variations thereof\n});'],longname:"module:$global/*",$href:"module:$global/*",$id:"T000002R000309"},{description:'<p>A module exposing the <em>global</em> <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window"><code>window</code></a> reference (in browsers) or whatever other object supposedly holds all <em>global</em> definitions.</p> <p>The primary intent of this module is to be used with <a href="https://developer.mozilla.org/en-US/docs/Web/Guide/Performance/Using_web_workers">web workers</a> where some (most?) of the <code>window</code> objects and methods are exposed through the <code>self</code> global reference, or with <em>Node.JS</em> where <code>global</code> is used.</p>',kind:"module",name:"$global",type:{names:["*"]},examples:["-\nEsquire.define(\"crypto\", ['$global'], function($global) {\n var subtle = $global.crypto.subtle;\n //...\n});"],longname:"module:$global",$href:"module:$global",$id:"T000002R000310"},{description:'<p>A module exposing a <a href="#!/#Promise"><code>Promise</code></a> constructor.</p>',kind:"module",name:"$promise",type:{names:["Promise"]},examples:['Combine a number of <a href="#!/#Promise"><code>Promise</code></a> instances.\nEsquire.define("myModule", [\'$promise\'], function(Promise) {\n // Combine a bunch of promises\n return Promise.all(...)\n   .then(function(results) {\n     // all results\n   });\n});'],longname:"module:$promise",$href:"module:$promise",$id:"T000002R000311"}])}();